<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Game of Life</title>
    <style>
        .container {
            display: flex;
            width: 90%;
            margin: 0 auto;
            align-items: flex-start;
            justify-content: space-between;
        }

        .left-panel {
            flex: 1;
            padding: 10px;
            box-shadow: 2px 0px 5px rgba(0, 0, 0, 0.1);
            margin-right: 20px;
        }

        /* Colorful labels */
        .left-panel label {
            color: #9cdcfe;
            /* Light blue, similar to variable color in VS Code */
        }

        /* Colorful input boxes */
        .left-panel input[type="number"],
        .left-panel textarea {
            background-color: #333333;
            /* Dark input background */
            color: #d4d4d4;
            /* Light text */
            border: 1px solid #555;
            /* Darker border */
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }


        canvas {
            max-width: 100%;
            height: auto;
            display: block;
            border: 1px solid #555;
            background-color: #2d2d2d;
        }


        .left-panel>div {
            background-color: #252526;
            /* Dark card background */
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }


        .right-panel {
            flex: 2;
            padding: 10px;
        }

        .left-panel>div:last-child {
            margin-bottom: 0;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.0/seedrandom.min.js"></script>
    <script src="file:///Users/matthewodonnell/gecs/games/extra_themes.js"></script>
</head>

<body>

    <div class="container">
        <div class="left-panel">
            <!-- Game Properties and Game Information -->
            <div>
                <strong>Current Score:</strong> <span id="currentScore">0</span>
                <strong>Top Score:</strong> <span id="topScore">0</span>
                <strong>Game State:</strong> <span id="gameState">Evolving</span>
            </div>
            <div>
                <label for="themeSelector">Choose Theme:</label>
                <select id="themeSelector"></select>

                <label for="population">Initial Population (%):</label>
                <input type="number" id="population" value="10" min="0" max="100">

                <label for="seed">Seed:</label>
                <input type="number" id="seed" value="0">

                <label for="stagnation">Stagnation Step Sample Length:</label>
                <input type="number" id="stagnation" value="100" max="1000" min="30">
            </div>
            <div>
                <!-- Game Controls -->
                <button id="startBtn">Start</button>
                <button id="pauseBtn" disabled>Pause</button>
                <button id="resetBtn">Reset</button>
            </div>

            <div>
                <label for="debugToggle">Debug Mode:</label>
                <input type="checkbox" id="debugToggle" checked="checked">
            </div>
        </div>

        <div class="right-panel">
            <!-- Game Display, Game Controls, and Debug Area -->
            <!-- Game Display -->
            <canvas id="gameCanvas" width="800" height="800" data-role="gameCanvas"></canvas>
        </div>
    </div>

    <script>
        const themes = {
            classic: { gridColor: 'lightgray', backgroundColor: 'darkgray', atomColor: 'black', atom3D: false, uiBackground: '#252526', uiText: '#d4d4d4', uiHighlight: '#9cdcfe' },
            ...ExtraThemes
        }

        let currentTheme = themes.classic;  // Default theme
        const themeSelector = document.getElementById('themeSelector');
        for (let theme in themes) {
            const option = document.createElement('option');
            option.value = theme;
            option.textContent = theme.charAt(0).toUpperCase() + theme.slice(1); // Capitalize theme name
            themeSelector.appendChild(option);
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 20;
        const rows = canvas.height / cellSize;
        const cols = canvas.width / cellSize;

        let grid = [];
        let previousStates = [];
        let score = 0;
        let topScore = 0;
        let animationId;
        let DEBUG = true;

        document.getElementById('debugToggle').addEventListener('change', function () {
            DEBUG = this.checked;
        });

        // Adjust canvas size based on window height
        function adjustCanvasSize() {
            const windowHeight = window.innerHeight;
            canvas.height = windowHeight * 0.8; // 80% of window height
            canvas.width = canvas.height; // Keep it square
        }

        window.addEventListener('resize', adjustCanvasSize);

        const storedTopScore = localStorage.getItem('topScore');
        if (storedTopScore) {
            topScore = parseInt(storedTopScore);
            document.getElementById('topScore').innerText = topScore;
        }

        function updateButtonStates(isGameRunning) {
            document.getElementById('startBtn').disabled = isGameRunning;
            document.getElementById('pauseBtn').disabled = !isGameRunning;
            document.getElementById('resetBtn').disabled = isGameRunning;
            document.getElementById('population').disabled = isGameRunning;
            document.getElementById('seed').disabled = isGameRunning;
            document.getElementById('stagnation').disabled = isGameRunning;
        }

        // Initialize grid with empty cells at session start
        function initializeEmptyGrid() {
            for (let i = 0; i < rows; i++) {
                grid[i] = [];
                for (let j = 0; j < cols; j++) {
                    grid[i][j] = 0;
                }
            }
            previousStates = [];
            // manageDebug("initializeEmptyGrid")
        }

        // Initialize grid with random cells at simulation start
        function initializeGrid() {
            const seed = parseInt(document.getElementById('seed').value);
            Math.seedrandom(seed.toString()); // Seed the random number generator

            for (let i = 0; i < rows; i++) {
                grid[i] = [];
                for (let j = 0; j < cols; j++) {
                    grid[i][j] = (Math.random() < (document.getElementById('population').value / 100)) ? 1 : 0;
                }
            }
            previousStates = [];
            // manageDebug("initializeGrid")
        }

        // Update grid for next generation
        function updateGrid() {
            let newGrid = [];
            for (let i = 0; i < rows; i++) {
                newGrid[i] = [];
                for (let j = 0; j < cols; j++) {
                    let neighbors = countNeighbors(i, j);
                    if (grid[i][j] === 1 && (neighbors < 2 || neighbors > 3)) {
                        newGrid[i][j] = 0;
                    } else if (grid[i][j] === 0 && neighbors === 3) {
                        newGrid[i][j] = 1;
                    } else {
                        newGrid[i][j] = grid[i][j];
                    }
                }
            }
            grid = newGrid;
        }

        // Count live neighbors for a cell
        function countNeighbors(x, y) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    let newX = (x + i + rows) % rows;
                    let newY = (y + j + cols) % cols;
                    count += grid[newX][newY];
                }
            }
            return count;
        }

        // Get stateDebugInfo
        function manageDebug(state = undefined) {
            if (DEBUG) {
                const liveCells = grid.flat().reduce((acc, val) => acc + val, 0);
                const debugInfo = {
                    now: Date.now(),
                    currentScore: score,
                    topScore: topScore,
                    liveCells: liveCells,
                    population: document.getElementById('population').value,
                    seed: document.getElementById('seed').value,
                    stagnation: document.getElementById('stagnation').value,
                    gameState: document.getElementById('gameState').innerText,
                };

                let debugString = state ? `State: ${state}\n` : '';
                debugString += "Debug Info:\n";


                console.log(Object.keys(debugInfo).map(key => `${key}: ${debugInfo[key]}`).join(' | ') + '\n');
            }
        }

        // Set button states
        function setButtonStates(startDisabled, pauseDisabled, resetDisabled) {
            document.getElementById('startBtn').disabled = startDisabled;
            document.getElementById('pauseBtn').disabled = pauseDisabled;
            document.getElementById('resetBtn').disabled = resetDisabled;
            document.getElementById('population').disabled = startDisabled;
            document.getElementById('seed').disabled = startDisabled;
            document.getElementById('stagnation').disabled = startDisabled;
        }

        function drawGridLines() {
            ctx.strokeStyle = currentTheme.gridColor; // Color of the grid lines
            ctx.lineWidth = 1; // Width of the grid lines

            // Vertical lines
            for (let i = 0; i <= cols; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let i = 0; i <= rows; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }
        }

        // Draw grid on canvas
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = currentTheme.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Use currentTheme values for grid lines and cell colors
            ctx.strokeStyle = currentTheme.gridColor;
            drawGridLines();

            ctx.fillStyle = currentTheme.atomColor;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (grid[i][j] === 1) {
                        // Base color of the cube
                        ctx.fillStyle = currentTheme.atomColor;;
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);

                        // // Top-left chamfer
                        // ctx.fillStyle = currentTheme.atomColor;; // Slightly darker shade
                        // ctx.beginPath();
                        // ctx.moveTo(j * cellSize, i * cellSize);
                        // ctx.lineTo(j * cellSize + cellSize * 0.2, i * cellSize);
                        // ctx.lineTo(j * cellSize, i * cellSize + cellSize * 0.2);
                        // ctx.closePath();
                        // ctx.fill();

                        // // Bottom-right chamfer
                        // ctx.fillStyle = currentTheme.atomColor;; // Even darker shade
                        // ctx.beginPath();
                        // ctx.moveTo(j * cellSize + cellSize, i * cellSize + cellSize);
                        // ctx.lineTo(j * cellSize + cellSize * 0.8, i * cellSize + cellSize);
                        // ctx.lineTo(j * cellSize + cellSize, i * cellSize + cellSize * 0.8);
                        // ctx.closePath();
                        // ctx.fill();
                    }
                }
            }
        }

        function hashGrid(grid) {
            // Implement a hashing function, e.g., using JSON.stringify or another efficient method
            return JSON.stringify(grid);
        }

        let stateHistory = [];

        function checkGameState() {
            const liveCells = grid.flat().reduce((acc, val) => acc + val, 0);

            if (liveCells === 0) {
                document.getElementById('gameState').innerText = 'Dead';
                endGame("Dead");
                return;
            }

            const currentStateHash = hashGrid(grid);
            stateHistory.push(currentStateHash);

            // Ensure stateHistory doesn't exceed the stagnation sample length
            const maxHistoryLength = parseInt(document.getElementById('stagnation').value);
            while (stateHistory.length > maxHistoryLength) {
                stateHistory.shift();
            }

            const recurringStates = stateHistory.filter(hash => hash === currentStateHash).length;

            // If the current state appears more than half the time in the history, consider it stagnate
            if (recurringStates > maxHistoryLength / 4) {
                document.getElementById('gameState').innerText = 'Stagnate';
                endGame("Stagnate");
                return;
            }
        }


        function endGame(reason = "") {
            // Stop the game loop
            cancelAnimationFrame(animationId);

            // Reset the stagnation counter
            stagnationCounter = 0;

            // Update the UI
            updateUIForGameEnd(reason);
        }


        function updateUIForGameEnd(reason) {
            // Update button states
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('resetBtn').disabled = false;
            document.getElementById('population').disabled = false;
            document.getElementById('seed').disabled = false;
            document.getElementById('stagnation').disabled = false;

            // Provide feedback to the user
            if (reason === "Stagnate") {
                console.log("The game has become stagnate. Please start a new session.");
            }
        }

        // Main game loop
        function gameLoop() {
            score++;
            document.getElementById('currentScore').innerText = score;
            if (score > topScore) {
                topScore = score;
                document.getElementById('topScore').innerText = topScore;
                localStorage.setItem('topScore', topScore);
            }
            updateGrid();
            drawGrid();
            checkGameState();
            animationId = requestAnimationFrame(gameLoop);
            updateButtonStates(true);
            manageDebug("gameLoop");  // Only call manageDebug here
        }

        // Event listeners
        document.getElementById('themeSelector').addEventListener('change', function () {
            currentTheme = themes[this.value];

            // Update UI colors
            document.body.style.backgroundColor = currentTheme.uiBackground;
            document.body.style.color = currentTheme.uiText;
            const labels = document.querySelectorAll('label');
            labels.forEach(label => label.style.color = currentTheme.uiHighlight);

            // Reflect theme changes on the canvas
            drawGrid();
        });

        document.getElementById('startBtn').addEventListener('click', function () {
            this.innerText = "Start"; // Reset the button text
            initializeGrid();
            drawGrid();
            score = 0;
            // manageDebug("start")
            gameLoop();
            updateButtonStates(true)
        });

        document.getElementById('pauseBtn').addEventListener('click', function () {
            document.getElementById('startBtn').innerText = "Resume"; // Change the button text
            cancelAnimationFrame(animationId);
            updateButtonStates(false);
            this.disabled = true;
            // manageDebug("paused")
        });

        document.getElementById('resetBtn').addEventListener('click', function () {
            cancelAnimationFrame(animationId);
            initializeEmptyGrid();
            drawGrid();
            score = 0;
            document.getElementById('currentScore').innerText = score;
            document.getElementById('gameState').innerText = '';
            updateButtonStates(false);
        });

        // Initialize on load
        adjustCanvasSize();
        initializeEmptyGrid();
        console.log('empty grid initialized')
        drawGrid();
        setButtonStates(false, true, false);  // Set initial button states
    </script>
</body>

</html>